<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Link Voyager</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #status { margin-top: 20px; }
    input, button { padding: 10px; margin: 5px; }
    .loader { display: inline-block; width: 12px; height: 12px; border: 2px solid #f3f3f3; border-radius: 50%; border-top: 2px solid #3498db; animation: spin 1s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    svg { border: 1px solid #ccc; margin-top: 20px; }
  </style>
</head>
<body>

  <h1>Hogar de los aves cartógrafas</h1>
  <h2>Se necesitan pájaros carpinteros</h2>

  <form id="explore-form">
    <label for="rootURL">Enter URL:</label>
    <input type="text" id="rootURL" placeholder="Enter URL" required>
    <button type="submit">Start Exploration</button>
  </form>

  <button id="stop-btn" style="display:none;">Stop Polling</button>

  <div id="status"></div>

  <!-- SVG for the D3.js graph -->
  <svg width="800" height="600"></svg>

  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
    let intervalId;

    document.getElementById('explore-form').addEventListener('submit', async function(event) {
      event.preventDefault();

      const rootURL = document.getElementById('rootURL').value;
      const statusDiv = document.getElementById('status');
      const stopBtn = document.getElementById('stop-btn');
      statusDiv.innerHTML = '<p>Sending request...</p>';
      stopBtn.style.display = 'none';  // Hide the stop button initially

      try {
        // First API call to start exploration
        const response = await fetch(`/link-voyager-maven/explorer?rootURL=${encodeURIComponent(rootURL)}`);
        const textResponse = await response.text();

        // Extract the UUID from the response
        const uuidMatch = textResponse.match(/([a-f0-9-]{36})/);
        if (uuidMatch) {
          const uuid = uuidMatch[0];
          statusDiv.innerHTML = `<p>Exploration queued with UUID: ${uuid}</p>`;

          // Show the stop button to allow the user to stop polling
          stopBtn.style.display = 'block';

          // Polling every second to check status using the UUID
          intervalId = setInterval(async function() {

            const statusResponse = await fetch(`/link-voyager-maven/explorer?uuid=${uuid}`);
            const statusText = await statusResponse.text();

            // Display the updated status
            statusDiv.innerHTML = `<p>Status update: ${statusText}</p>`;

            // Stop polling if exploration is completed
            if (statusText.includes("_In phase_  : DONE")) {
              clearInterval(intervalId);
              statusDiv.innerHTML += "<p>Exploration completed!</p>";
              stopBtn.style.display = 'none';  // Hide the stop button after completion

              // Fetch the links using the uuidJSON endpoint
              const jsonResponse = await fetch(`/link-voyager-maven/explorer?uuidJson=${uuid}`);
              const links = await jsonResponse.json();


              // Call the D3 graph function to render the visualization
              drawGraph(links);
            } else {
              statusDiv.innerHTML += `<span class="loader"></span> Checking status...<br/>`;
            }
          }, 1000); // 1 second interval
        } else {
          statusDiv.innerHTML = "<p>Error: Unable to extract UUID from response.</p>";
        }

      } catch (error) {
        statusDiv.innerHTML = `<p>Error: ${error.message}</p>`;
      }
    });

    // Function to stop the polling
    document.getElementById('stop-btn').addEventListener('click', function() {
      if (intervalId) {
        clearInterval(intervalId);
        document.getElementById('status').innerHTML += '<p>Polling stopped by user.</p>';
        this.style.display = 'none';  // Hide the stop button after stopping
      }
    });

    // D3.js graph drawing function
    function drawGraph(links) {
    	const width = 800;  // Define el ancho del SVG
    	const height = 600; // Define el alto del SVG

    	const svg = d3.select("svg")
    	    .attr("width", width)
    	    .attr("height", height);

    	// Crear un grupo para el gráfico
    	const g = svg.append("g");

    	// Define la simulación con fuerza
    	const simulation = d3.forceSimulation()
    	    .force("link", d3.forceLink().id(d => d.id).distance(50))
    	    .force("charge", d3.forceManyBody().strength(-400))
    	    .force("center", d3.forceCenter(width / 2, height / 2));

    	const nodes = Array.from(new Set(links.flatMap(l => [l.source, l.target]))).map(id => ({ id }));

    	// Dibujar las flechas (marcadores de punta de flecha)
    	g.append("defs").selectAll("marker")
    	    .data(["end"]) // Marca el final de las líneas
    	  .enter().append("marker")
    	    .attr("id", "arrow")
    	    .attr("viewBox", "0 -5 10 10")
    	    .attr("refX", 20)
    	    .attr("refY", 0)
    	    .attr("markerWidth",  15)
    	    .attr("markerHeight", 15)
    	    .attr("orient", "auto")
    	  .append("path")
    	    .attr("d", "M0,-5L10,0L0,5")
    	    .attr("class", "arrow");

    	// Dibuja los enlaces (links) como líneas
    	const link = g.append("g")
    	    .attr("class", "links")
    	  .selectAll("line")
    	  .data(links)
    	  .enter().append("line")
    	    .attr("class", "link")
    	    .attr("stroke", "black")
    	    .attr("marker-end", "url(#arrow)");

    	// Dibuja los nodos como círculos
    	const node = g.append("g")
    	    .attr("class", "nodes")
    	  .selectAll("circle")
    	  .data(nodes)
    	  .enter().append("circle")
    	    .attr("class", "node")
    	    .attr("r", 10)
    	    .call(d3.drag() // Habilitar el arrastre en los nodos
    	      .on("start", dragstarted)   // Al comenzar el arrastre
    	      .on("drag", dragged)        // Durante el arrastre
    	      .on("end", dragended));     // Al finalizar el arrastre

    	// Agrega etiquetas de texto a los nodos
    	const label = g.append("g")
    	    .attr("class", "labels")
    	  .selectAll("text")
    	  .data(nodes)
    	  .enter().append("text")
    	    .attr("dy", -15)
    	    .attr("text-anchor", "middle")
    	    .text(d => d.id);

    	// Actualiza la simulación en cada tick
    	simulation
    	  .nodes(nodes)
    	  .on("tick", ticked);

    	simulation.force("link")
    	  .links(links);

    	// Configurar la escala del zoom
    	const zoom = d3.zoom()
    	    .scaleExtent([0.1, 5])  // Limita el rango de escalado
    	    .on("zoom", (event) => {
    	        g.attr("transform", event.transform);
    	    });

    	// Aplicar el zoom al SVG
    	svg.call(zoom);

    	function ticked() {
    	  link
    	      .attr("x1", d => d.source.x)
    	      .attr("y1", d => d.source.y)
    	      .attr("x2", d => d.target.x)
    	      .attr("y2", d => d.target.y);

    	  node
    	      .attr("cx", d => d.x)
    	      .attr("cy", d => d.y);

    	  label
    	      .attr("x", d => d.x)
    	      .attr("y", d => d.y);
    	}

    	// Funciones para el arrastre de nodos
    	function dragstarted(event, d) {
    	  if (!event.active) simulation.alphaTarget(0.3).restart();
    	  d.fx = d.x;
    	  d.fy = d.y;
    	}

    	function dragged(event, d) {
    	  d.fx = event.x;
    	  d.fy = event.y;
    	}

    	function dragended(event, d) {
    	  if (!event.active) simulation.alphaTarget(0);
    	  d.fx = null;
    	  d.fy = null;
    	}

    }
  </script>

</body>
</html>
