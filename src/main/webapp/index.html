<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="/link-voyager-maven/d3.js"></script>
<script src="/link-voyager-maven/link-voyager.js"></script>

<title>Link Voyager</title>
<style>
body {
	font-family: Arial, sans-serif;
	margin: 20px;
}

#status {
	margin-top: 20px;
}

input, button {
	padding: 10px;
	margin: 5px;
}

.loader {
	display: inline-block;
	width: 12px;
	height: 12px;
	border: 2px solid #f3f3f3;
	border-radius: 50%;
	border-top: 2px solid #3498db;
	animation: spin 1s linear infinite;
}

@keyframes spin { 100% {
	transform: rotate(360deg);
}

}
svg {
	border: 1px solid #ccc;
	margin-top: 20px;
}

table {
	border-collapse: collapse;
	width: 100%;
	margin-top: 20px;

    table-layout: fixed;

    /* thanks https://stackoverflow.com/a/19623358/903998 for the tips */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

th, td {
	border: 1px solid #000; /* Bordes de las celdas */
	padding: 8px; /* Espaciado interno */
	text-align: left; /* Alineación del texto */
}

tr:nth-child(even) {
	background-color: #f2f2f2;
	/* Color de fondo alternado para las filas */
}

select, input {
  border: 1px solid #007BFF;
  border-radius: 5px;
  padding: 5px;
}

select:focus, input:focus {
  outline: none;
  border-color: #0056b3;
}
</style>
</head>
<body>

	<h1>
		Hogar de las aves cartógrafas <a href="about.html" style="font-size: 0.8em;">(Acerca de)</a>  <a href="help.html" style="font-size: 0.8em;">(Ayuda)</a>
	</h1>
	<h2>Se necesitan pájaros carpinteros</h2>

	<form id="explore-form">
		<label for="rootUrl">URL:</label>
		<input type="text" id="rootUrl" placeholder="Ingresar URL" required>

		<label for="deep-select">Profundidad de exploración:</label>
		<select name="deep" id="deep-select">
			<option value="0">1 Página</option>
			<option value="1">2 Páginas</option>
			<option value="2" selected>3 Páginas</option>
			<option value="3">4 Páginas</option>
			<option value="4">5 Páginas</option>
			<option value="5">6 Páginas</option>
		</select>

		<!-- Select para la cantidad de exploradoras -->
		<label for="workers-input">Cantidad de exploradoras:</label>
		<input name="workers" id="workers-input" type="number"  placeholder="Escribe un número" value="5" min="1" max="50"/>

		<button type="submit" id="explore-btn">Explorar!</button>
		<br>
		<p style="font-size: 0.7em; font-weight: bold;">Se pueden explorar hasta 500 páginas...</p>
	</form>

	<button id="stop-btn" style="display: none;">
		Detener actualización <small>(El proceso sigue igual)</small>
	</button>

	<div id="status"></div>
	<div id="nodes-visited"></div>

	<!-- SVG for the D3.js graph -->
	<svg width="800" height="600"></svg>

	<script>
    let intervalId;
    const svg = d3.select("svg");
    let simulation;

    // Función para limpiar el gráfico
    function clearGraph() {
      svg.selectAll("*").remove(); // Elimina todos los elementos en el SVG
      if (simulation) {
        simulation.stop(); // Detiene la simulación si está activa
      }
    }


    function generateTableFromStringAndInsertIntoDOM(input) {

    	function extractInputForTable(input) {
    	    // Expresión regular para encontrar "Processing : <NUMERO>" y capturar el texto que sigue
    	    const regex = /Procesing : \d*\s*/;

    	    const match = input.match(regex); // Aplicar la regex al input

    	    if (match) {
    	        // Obtener el índice donde termina el match
    	        const matchEndIndex = match.index + match[0].length;

    	        // Retornar todo el texto después del número
    	        return input.substring(matchEndIndex).trim();
    	    } else {
    	        return null; // Retornar null si no hay coincidencia
    	    }
    	}
        // Dividir el input por el delimitador '|'
        const inputForTable = extractInputForTable(input);
        const elements = inputForTable.split('|')
        elements.pop() // esta al dope
        const pairs = []
        for (let index = 0; index < elements.length; index = index + 2) {
          const left = elements[index];
          const right = elements[index+1];
          pairs.push({left: left, right: right});
        }

        // Crear la tabla
        const table = document.createElement('table');
        table.setAttribute('id', 'explored-pages');
        const tbody = document.createElement('tbody');

        // Recorrer los pares y crear filas
        pairs.forEach(pair => {
            const row = document.createElement('tr');
            const cell1 = document.createElement('td');
            cell1.textContent = pair.left; // Asignar el texto del par a la celda
            row.appendChild(cell1); // Agregar la celda a la fila
            const cell2 = document.createElement('td');
            cell2.textContent = pair.right; // Asignar el texto del par a la celda
            row.appendChild(cell2); // Agregar la celda a la fila
            tbody.appendChild(row); // Agregar la fila al cuerpo de la tabla
        });

        table.appendChild(tbody); // Agregar el cuerpo a la tabla
        const nodesVisitedHtmlElement = document.getElementById('nodes-visited')
        nodesVisitedHtmlElement.innerHTML = "";
        nodesVisitedHtmlElement.appendChild(table);
    }

    document.getElementById('explore-form').addEventListener('submit', async function(event) {
      event.preventDefault();

      const statusDiv = document.getElementById('status');
      statusDiv.innerHTML = '<p>Enviando petición...</p>';

      const stopBtn = document.getElementById('stop-btn');
      const exploreBtn = document.getElementById('explore-btn');
      exploreBtn.style.display = 'none';
      stopBtn.style.display = 'block';

      clearGraph(); // Limpia el gráfico antes de la nueva solicitud
      // Elimina la tabla existente si la hay
      const existingTable = document.getElementById('explored-pages');
      if (existingTable) {
        existingTable.remove();
      }

      try {
        const rootUrl = document.getElementById('rootUrl').value;
    	  const exploreDeep = document.getElementById('deep-select').value;
    	  const exploreWorkers = document.getElementById('workers-input').value;

        const uuid = await LinkVoyager.DefaultApi.startExploration(rootUrl, exploreDeep, exploreWorkers)
        if (uuid) {
          statusDiv.innerHTML = `<p>Exploration queued with UUID: ${uuid}</p>`;
          stopBtn.style.display = 'block'; // Show the stop button to allow the user to stop polling

          statusDiv.innerHTML = `<span>Explorando&nbsp;</span><span class="loader"></span><br/>`;

          intervalId = setInterval(async function() {
            const statusText = await LinkVoyager.DefaultApi.checkStatus(uuid)
            generateTableFromStringAndInsertIntoDOM(statusText)
            if (statusText.includes("_In phase_  : DONE")) {
              clearInterval(intervalId);

              statusDiv.innerHTML = "<p>Exploration completed!</p>";

              stopBtn.style.display = 'none';
              exploreBtn.style.display = 'inline-block';

              const links = await LinkVoyager.DefaultApi.getLinks(uuid, rootUrl)
              drawGraph(links);
            }
          }, 1000);
        } else {
          statusDiv.innerHTML = `<p>Error: No se pudo extraer UUID de la respuesta.</p><p>Respuesta: ${textResponse}</p>`;
          exploreBtn.style.display = 'inline-block';
        }

      } catch (error) {
        statusDiv.innerHTML = `<p>Error: ${error.message}</p>`;
        exploreBtn.style.display = 'inline-block';
      }
    });

    // Function to stop the polling
    document.getElementById('stop-btn').addEventListener('click', function() {
      if (intervalId) {
        clearInterval(intervalId);
        document.getElementById('status').innerHTML += '<p>Actualización detenida.</p>';
        this.style.display = 'none';  // Hide the stop button after stopping
      }
    });

    // D3.js graph drawing function
    function drawGraph(links) {
    	const width = 800;  // Define el ancho del SVG
    	const height = 600; // Define el alto del SVG

    	const svg = d3.select("svg")
    	    .attr("width", width)
    	    .attr("height", height);

    	// Crear un grupo para el gráfico
    	const g = svg.append("g");

    	// Define la simulación con fuerza
    	/*simulation = d3.forceSimulation()
          .force("link", d3.forceLink().id(d => d.id).distance(30))
			.force("charge", d3.forceManyBody()
			    .strength(-300)       // La fuerza de repulsión
			    .distanceMin(50)      // Distancia mínima a la que la fuerza tiene efecto
			    .distanceMax(200)     // Distancia máxima a la que la fuerza tiene efecto
			)
      .alphaDecay(0.05)  // Aumentar el decaimiento para que la simulación se detenga más rápido
    	    .force("center", d3.forceCenter(width / 2, height / 2))
          //.force("collide", d3.forceCollide().radius(d => d.size + 5))
              .force("collide", d3.forceCollide(20))  // Aumentar el radio de colisión para evitar superposición
*/

// thanks a lot https://observablehq.com/@ee2dev/d3-force-playground for allowing me to calibrate the visualization of this graph!
	simulation =  d3.forceSimulation()
.force("link", d3.forceLink().id(d => d.id).distance(50))
.force("center", d3.forceCenter(width / 2, height / 2))
// Eliminar o reducir la repulsión si no es necesaria
.force("charge", d3.forceManyBody().strength(-20).distanceMin(20).distanceMax(150))
.force("collide", d3.forceCollide().strength(2).radius(50).iterations(10))  // Menor radio de colisión para mejorar rendimiento
.alphaDecay(0.05)  // Simulación más rápida

    	const nodes = Array.from(new Set(links.flatMap(l => [l.source, l.target]))).map(id => ({ id }));

    	// Dibujar las flechas (marcadores de punta de flecha)
    	/*g.append("defs").selectAll("marker")
    	    .data(["end"]) // Marca el final de las líneas
    	    .enter().append("marker")
    	    .attr("id", "arrow")
          .attr("class", "arrow")
    	   .attr("viewBox", "0 -5 10 10")
    	    .attr("refX", 20)
    	    .attr("refY", 0)
    	    .attr("markerWidth",  10)
    	    .attr("markerHeight", 10)
    	    .attr("orient", "auto")
    	  	.append("path")
    	    .attr("d", "M0,-5L10,0L0,5")
    	    .attr("class", "arrow")*/
    	 // Definir el marcador de flecha
    	    svg.append("defs").append("marker")
    	        .attr("id", "arrow")
    	        .attr("viewBox", "0 -5 10 10")
    	        .attr("refX", 16)  // Posición de la flecha respecto al enlace
    	        .attr("refY", 0)
    	        .attr("markerWidth", 6)
    	        .attr("markerHeight", 6)
    	        .attr("orient", "auto")
    	        .append("path")
    	        .attr("d", "M0,-5L10,0L0,5")  // Definición de la flecha en forma de triángulo
    	        .attr("fill", "black");  // Color de la flecha


    	// Dibuja los enlaces (links) como líneas
    	const link = g.append("g")
    	    .attr("class", "links")
          .selectAll("line")
          .data(links)
          .enter().append("line")
    	    .attr("class", "link")
    	    //.attr("stroke", "black")
		    .style("stroke", function(d) {
		        if (d.level === 0) {
		            return "lightcoral";  // Color para enlaces de nivel 1
		        } else if (d.level === 1) {
		            return "blue";  // Color para enlaces de nivel 2
		        } else {
		            return "gray";  // Color para otros enlaces si lo deseas
		        }
		    })
          	.attr("stroke-width", d => Math.sqrt(d.value))
    	    .attr("marker-end", "url(#arrow)");

    	// Dibuja los nodos como círculos
      const rootUrl = document.getElementById('rootUrl').value;
    	const node = g.append("g")
    	    .attr("class", "nodes")
    	  .selectAll("circle")
    	  .data(nodes)
    	  .enter().append("circle")
    	    .attr("class", "node")
          .attr("r", function(d) {
            if (d.id === rootUrl) {
                return 10;  // Tamaño mayor para el nodo raíz
            } else {
                return 5;   // Tamaño normal para los demás nodos
            }
          })
          .style("fill", function(d) {
              if (d.id === rootUrl) {
                  return "red";  // Color rojo para el nodo raíz
              } else {
                  return "blue";  // Color para el resto de los nodos
              }
          })
    	    .call(d3.drag() // Habilitar el arrastre en los nodos
    	      .on("start", dragstarted)   // Al comenzar el arrastre
    	      .on("drag", dragged)        // Durante el arrastre
    	      .on("end", dragended));     // Al finalizar el arrastre

    	// Agrega etiquetas de texto a los nodos
    	/*const label = g.append("g")
    	    .attr("class", "labels")
          .selectAll("text")
          .data(nodes)
          .enter().append("text")
          .attr("dy", -10)  // Ajusta la posición vertical del texto
          .attr("font-size", "8px")  // Cambia el tamaño de la fuente
          .attr("text-anchor", "middle")
          .text(d => d.id);*/

          const label = g.append("g")
          .attr("class", "labels")
          .selectAll("text")
          .data(nodes)
          .enter().append("text")
          .attr("class", "label")
          .attr("dy", -10)  // Ajuste para mostrar el texto encima del nodo
          .attr("text-anchor", "middle")
          .style("font-size", "10px")  // Ajusta el tamaño del texto si es necesario
          .style("display", "none")  // Inicialmente ocultos
          .text(d => d.id);  // Mostrar el ID como texto

      // Mostrar/Ocultar textos cuando el mouse está sobre los nodos
      node.on("mouseover", function(event, d) {
          // Mostrar el texto correspondiente al nodo
          label.filter(n => n.id === d.id).style("display", "block");
      })
      .on("mouseout", function(event, d) {
          // Ocultar el texto cuando el mouse sale del nodo
          label.filter(n => n.id === d.id).style("display", "none");
      });

      // Función para obtener nodos adyacentes
      function getAdjacentNodes(selectedNodeId) {
          // Obtener los nodos adyacentes a través de los enlaces
          const adjacentNodes = link
              .filter(l => l.source.id === selectedNodeId || l.target.id === selectedNodeId)
              .data()
              .map(l => l.source.id === selectedNodeId ? l.target.id : l.source.id);

          // También incluir el nodo seleccionado en la lista de nodos adyacentes
          adjacentNodes.push(selectedNodeId);

          return adjacentNodes;
      }

      // Función para mostrar solo nodos adyacentes
      function showAdjacentNodes(selectedNodeId) {
          const adjacentNodes = getAdjacentNodes(selectedNodeId);

          // Mostrar solo nodos adyacentes y ocultar los demás
          node.style("display", d => adjacentNodes.includes(d.id) ? "block" : "none");
          //label.style("display", d => adjacentNodes.includes(d.id) ? "block" : "none");
      }
   // Función para mostrar todos los nodos
      function showAllNodes() {
          node.style("display", "block");
          //label.style("display", "block");
      }
      let showingAllNodes = true;
		   // Agregar evento de clic a los nodos
		   node.on("click", function(event, d) {
		       if (showingAllNodes) {
		           showAdjacentNodes(d.id);  // Mostrar solo los adyacentes si todos están visibles
		       } else {
		           showAllNodes();  // Mostrar todos los nodos si los adyacentes están visibles
		       }
		       showingAllNodes = !showingAllNodes;  // Alternar estado
		   });

    	// Actualiza la simulación en cada tick
    	simulation
    	  .nodes(nodes)
    	  .on("tick", ticked);

    	simulation.force("link")
    	  .links(links);

    	// Configurar la escala del zoom
    	const zoom = d3.zoom()
    	    .scaleExtent([0.1, 5])  // Limita el rango de escalado
    	    .on("zoom", (event) => {
    	        g.attr("transform", event.transform);
    	    });

    	// Aplicar el zoom al SVG
    	svg.call(zoom);

    	function ticked() {
    	  link
    	      .attr("x1", d => d.source.x)
    	      .attr("y1", d => d.source.y)
    	      .attr("x2", d => d.target.x)
    	      .attr("y2", d => d.target.y);

    	  node
    	      .attr("cx", d => d.x)
    	      .attr("cy", d => d.y);

    	  label
    	      .attr("x", d => d.x)
    	      .attr("y", d => d.y);
    	}

    	// Funciones para el arrastre de nodos
    	function dragstarted(event, d) {
    	  if (!event.active) simulation.alphaTarget(0.3).restart();
    	  d.fx = d.x;
    	  d.fy = d.y;
    	}

    	function dragged(event, d) {
    	  d.fx = event.x;
    	  d.fy = event.y;
    	}

    	function dragended(event, d) {
    	  if (!event.active) simulation.alphaTarget(0);
    	  d.fx = null;
    	  d.fy = null;
    	}

    }
  </script>

</body>
</html>
